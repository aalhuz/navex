/**
 * @author Abeer Alhuzali
 * This class reads/extracts information from the set of TAC formulas generated by the Enhanced CPG traversals (in the paper algorithm 1)
 * For more information, please read "NAVEX: Precise and Scalable Exploit Generation for Dynamic Web Applications"
 *
 */
package navex.solver;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import navex.Main;
import edu.uci.ics.crawler4j.util.IO;
import navex.formula.StaticFormulaInfo;


public class StaticSolver {

	private static final Logger logger = LoggerFactory.getLogger(Main.class);


	public static void main(String[] args) {

		/*
		 * creating spec files
		 * 
		 *
		 */


		Scanner scanner = new Scanner(System.in);
		System.out.println("\nPlease enter the attack type (sql, xss, code, os-command, file-inc, or ear): ");
		String attackType = scanner.next().trim();

		
		System.out.println("\nPlease enter the static analysis results file name (and full path) : ");
		String results_File = scanner.next().trim();
		
		
		long startTime = System.currentTimeMillis();

		HashSet<StaticFormulaInfo> st = new HashSet<StaticFormulaInfo>();

		logger.debug(" ....Starting to generate Spec files for the list of static analysis formulas ....");

		switch (attackType){
		case "sql":
		case "xss": 
		case "code": //code execution
		case "os-command": //command injection
		case "file-inc": //file inclusion
			st = IO.readStaticAnalysisResultFile(results_File, attackType);
			break;
		case "ear": 
			st = IO.readStaticAnalysisResultFileEar(results_File, attackType);
			break;
		}
		mainHelper(st, attackType);


		long analysisEndTime = System.currentTimeMillis();
		long analysisDiffTime = (analysisEndTime - startTime);

		System.out.println("=====TOTAL: resolving inclusion + generating Spec Files + solving them====="+analysisDiffTime);



	}

	public static void mainHelper(HashSet<StaticFormulaInfo> st, String attackType){

		HashMap<String, ArrayList<String>> incMap = IO.processIncludeMap(); 
		HashSet<String> hs = new HashSet<String>();

		for (StaticFormulaInfo s : st){
			System.out.println("\n "+ s.toString());

			String part1 = s.getFile().replace("]", "");

			String cFile = "staticAnalysisSpec"+part1+"__"+s.getLineno()+"__"+s.getNode_id()+"__"+s.getSinkType()+"__"+s.getUnique_id();
			String get = null;  ArrayList<String> candidateUrls= null;
			SolverModel model= null;
			List<NameValuePair> varval =null;

			if (!attackType.contains("ear"))
			{
				model = getSolver(s);


				processModel(model , incMap, get, candidateUrls, varval);
			}
			else 
				candidateUrls = resolveIncludeMapAndSolverModel(model, incMap, part1);


			/*
			 * Now we have to store this information in a file to feed it to 
			 * the traversal after performing the dynamic analysis.
			 */
			String str = CreateIncludeMapResolutionFile(model, get,  candidateUrls, varval, incMap, cFile);


			boolean added= hs.add(str);
			//Edit the paths as needed .. 
			if (added && attackType.contains("sql"))
				IO.writeToFile("/home/user/navex/results/include_map_resolution_results.txt", str, true);
			else if (added && attackType.contains("xss")){
				IO.writeToFile("/home/user/navex/results/include_map_resolution_results_xss.txt", str, true);
			}
			else if (added && attackType.contains("code")){
				IO.writeToFile("/home/user/navex/results/include_map_resolution_results_code.txt", str, true);
			}
			else if (added && attackType.contains("os-command")){
				IO.writeToFile("/home/user/navex/results/include_map_resolution_results_os-command.txt", str, true);
			}
			else if (added && attackType.contains("file-inc")){
				IO.writeToFile("/home/user/navex/results/include_map_resolution_results_file-inc.txt", str, true);
			}
			else if (added && attackType.contains("ear")){
				IO.writeToFile("/home/user/navex/results/include_map_resolution_results_ear.txt", str, true);
			}
			
			System.out.println(">>>>>>>>>>>>>>>>DONE >>>>>>>>>>>>>>>>>");

		} 

	}
  //Edit paths to files as need
	private static String CreateIncludeMapResolutionFile(SolverModel model, String get, ArrayList<String> candidateUrls,
			List<NameValuePair> varval, HashMap<String, ArrayList<String>> incMap, String cFile) {


		String str= ""; 

		if (model != null){
			if ( get != null || model.getGetMap().size() > 0  || model.getNvps().size() > 0){

				for (String src :findSrcUrl(cFile))
				{
					System.out.println("source  url is "+src);
					if (incMap != null  ){
						str="FILE:"+cFile+"\n";
						str+= "SRC_URL:"+src+"\n"; 
					}
					str+="DEST_URL: ";
					if (candidateUrls != null && candidateUrls.size() > 0 ){

						for (String u : candidateUrls)
						{ str+=u+" ";
						System.out.println("u   "+u);

						}


					}
					else if ( (candidateUrls == null || candidateUrls.size() == 0) && model.getUrl() != null) {
						System.out.println("model.getUrl "+model.getUrl());
						str+= model.getUrl();
					}

					if (varval != null){
						str+="\nNameValuePair: ";
						for (NameValuePair p :varval){
							str+=p.toString()+" ";
						}
					}
					str+="\nget: ";
					if (get != null)
						str+=get;

				}
			}
		}	
		
		//in case of ear vulnerabilities
		else {
			for (String src :findSrcUrl(cFile))
			{   String localhost= "http://localhost/";
				
			    System.out.println("source  url is "+src);
				if (incMap != null  ){
					str="FILE:"+cFile+"\n";
					str+= "SRC_URL:"+src+"\n"; 
				    int index = src.indexOf("http://192.168.0.123");
					if (index != -1)
					    localhost = src.substring(0,index+("http://192.168.0.123/".length()) ); 
				}
				str+="DEST_URL: ";
				if (candidateUrls != null && candidateUrls.size() > 0 ){

					for (String u : candidateUrls)
					{ str+=u+" ";
					System.out.println("u   "+u);

					}
                  }
				else if ( (candidateUrls == null || candidateUrls.size() == 0) ) {
				   {
					   String url = cFile.replace("staticAnalysisSpec/var/www/html/", 
							   			localhost);
					   url= url.substring(0, url.indexOf("__"));
					   str+=url;
				   }
				   
				   }
	

			   str+="\nNameValuePair: ";
			
				str+="\nget: ";
				
			}
		}
		return str;		
	}
	/*
	 * once we have a model + include map, 
	 * we filter all SAT models and resolve the url from the 
	 * include map 
	 * output: list of destination urls with their NameValuePairs
	 */

	private static void processModel(SolverModel model, HashMap<String, ArrayList<String>> incMap
			,String get , ArrayList<String> candidateUrls,List<NameValuePair> varval ) {
		if (model.getSolution() != null && model.getUrl() != null && model.getSolution().startsWith("SAT")){
			int index = model.getUrl().indexOf("?");
			if (index != -1 )
				get = model.getUrl().substring(index+1);

			candidateUrls = resolveIncludeMapAndSolverModel(model, incMap, "");
			varval = model.getNvps(); 

		}


	}

	private static SolverModel getSolver(StaticFormulaInfo s) {
		
		Solver solve = new Solver(s.getFormula(), s.getSinkType());
		String spec = solve.prepareSolver();
		String part1 = s.getFile().replace("]", "");//.replace("/", "+").
		String cFile = "staticAnalysisSpec"+part1+"__"+s.getLineno()+"__"+s.getNode_id()+"__"+s.getSinkType()+"__"+s.getUnique_id();
		IO.writeToFile(cFile, spec, false);

		/*
		 * sending spec files to Z3 solver
		 */

		Main.invokeSolver(cFile);

		System.out.println("---------------------------Done---");


		/*
		 * read the generated model and create an HTTP request 
		 */

		SolverModel model = translateZ3model(cFile, s.getFile());

		return model;

	}

	
  /*
   * This is very specific to the tested apps in navex
   * please edit before testing
   */
	private static ArrayList<String> findSrcUrl(String url) {
		ArrayList<String> strl = null;
		String str=null;
		if (url.contains("/WeBid-v0.5.4")){
			strl= new ArrayList<String>();
			str="http://localhost/WeBid-v0.5.4/admin/login.php";
			strl.add(str);
			strl.add("http://localhost/WeBid-v0.5.4/index.php");
		}
		else if(url.toLowerCase().contains("zen-cart-1.5.5e")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/zen-cart-1.5.5e/index.php");
		}

		else if(url.toLowerCase().contains("/collabtive-12/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/collabtive-12/index.php");
		}

		else if(url.contains("/phpBB2/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/phpBB2/index.php");
			strl.add("http://localhost/phpBB2/admin/index.php");
		}

		else if(url.toLowerCase().contains("/oscommerce-2.3.3/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/oscommerce-2.3.3/catalog/index.php");
			strl.add("http://localhost/oscommerce-2.3.3/catalog/admin/index.php");
		}

		else if(url.toLowerCase().contains("/hotcrp-2.60/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/hotcrp-2.60/index.php");
		}

		return strl;
	}

	private static ArrayList<String> resolveIncludeMapAndSolverModel(SolverModel model,
			HashMap<String, ArrayList<String>> incMap, String fileName) {

		ArrayList<String> cadidateUrls =null;
   if (model != null){
		if (model.getSolution() != null && model.getSolution().startsWith("SAT"))
		{
			String urlOnly = null;
			if (model.getUrl().indexOf(".php") != -1)
				urlOnly= model.getUrl().substring(model.getUrl().lastIndexOf("/")+1, model.getUrl().indexOf(".php")+4);
			else if (model.getUrl().indexOf(".inc") != -1)
				urlOnly= model.getUrl().substring(model.getUrl().lastIndexOf("/")+1, model.getUrl().indexOf(".inc")+4);

			int start = model.getUrl().indexOf("localhost/")+10;
			String appName= model.getUrl().substring(start, model.getUrl().indexOf("/", start));
			String fromAppNameToEnd = null;
			if (model.getUrl().indexOf(".php") != -1)
				fromAppNameToEnd =model.getUrl().substring(model.getUrl().indexOf(appName) , model.getUrl().indexOf(".php")+4) ;
			else if (model.getUrl().indexOf(".inc") != -1)
				fromAppNameToEnd =model.getUrl().substring(model.getUrl().indexOf(appName) , model.getUrl().indexOf(".inc")+4) ;

			System.out.println(" model.getUrl() "+ model.getUrl()+"   urlOnly "+urlOnly+
					"  appName: "+appName+"  fromAppNameToEnd :"+fromAppNameToEnd);
			if (!incMap.containsKey(fromAppNameToEnd) ){ 

				cadidateUrls = new ArrayList<String>();
				for (Map.Entry<String, ArrayList<String>> map: incMap.entrySet()){
					if (map.getKey().contains(appName)){
						for (String val : map.getValue()){
							if ((val).contains(urlOnly) ){ 
								System.out.println("val "+val);
								cadidateUrls.add(map.getKey());
							}
						}
					}
				}
			}
		}
   }
   //model == null in case of ear vulnerabilities
   //"/var/www/html/" is the location of the deployed apps evaluated in navex. Edit as needed
		else {
			String urlOnly = null;
			//if there was post vars
			if (fileName.indexOf(".php") != -1)
				urlOnly= fileName.substring(fileName.lastIndexOf("/")+1, fileName.indexOf(".php")+4);
			else if (fileName.indexOf(".inc") != -1)
				urlOnly= fileName.substring(fileName.lastIndexOf("/")+1, fileName.indexOf(".inc")+4);

			int start = fileName.indexOf("/var/www/html/")+("/var/www/html/".length());
			String appName= fileName.substring(start, fileName.indexOf("/", start));
			String fromAppNameToEnd = null;
			if (fileName.indexOf(".php") != -1)
				fromAppNameToEnd =fileName.substring(fileName.indexOf(appName) , fileName.indexOf(".php")+4) ;
			else if (fileName.indexOf(".inc") != -1)
				fromAppNameToEnd =fileName.substring(fileName.indexOf(appName) , fileName.indexOf(".inc")+4) ;

			System.out.println(" fileName "+ fileName+"   urlOnly "+urlOnly+
					"  appName: "+appName+"  fromAppNameToEnd :"+fromAppNameToEnd);
			if (!incMap.containsKey(fromAppNameToEnd) ){ 

				cadidateUrls = new ArrayList<String>();
				for (Map.Entry<String, ArrayList<String>> map: incMap.entrySet()){
					if (map.getKey().contains(appName)){
						for (String val : map.getValue()){
							//System.out.println("val "+val);
							if ((val).contains(urlOnly) ){  //val).equals(urlOnly)
								System.out.println("val "+val);
								cadidateUrls.add(map.getKey());
							}
						}
					}
				}
			}
		}
		return cadidateUrls;

	}

/*
 * "/var/www/html/" is the location of the deployed apps evaluated in navex. Edit as needed
 *  Localhost is our test server. Edit as needed
 */

	private static SolverModel translateZ3model(String cFile, String url) {

		url = url.replace("/var/www/html", "http://localhost").trim();
		String[] mArgs = {cFile+".model", "" ,  url, "static"};
		List <NameValuePair> params = null;
		SolverModel model = new SolverModel();
		try {
			params = model.main(mArgs, null);
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (URISyntaxException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(IllegalThreadStateException e){
			e.printStackTrace();
		}
		
		System.out.println("the model url is "+model.getUrl());
		System.out.println("the model <val,value> is "+model.getNvps().toString());

		return model;

	}




}
